
/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_EOF;
%token TOKEN_WHILE;
%token TOKEN_IF;
%token TOKEN_ELSE;
%token TOKEN_FOR;
%token TOKEN_PRINT;
%token TOKEN_TRUE;
%token TOKEN_FALSE;
%token TOKEN_RETURN;
%token TOKEN_ADD;
%token TOKEN_MULTIPLY;
%token TOKEN_DIVIDE;
%token TOKEN_MOD;
%token TOKEN_SUBTRACT;
%token TOKEN_POWER;
%token TOKEN_DECREMENT;
%token TOKEN_INCREMENT;
%token TOKEN_IDENT;
%token TOKEN_C_COMMENT;
%token TOKEN_COMMENT;
%token TOKEN_NUMBER;
%token TOKEN_STRING;
%token TOKEN_CHAR;
%token TOKEN_TYPE_STRING;
%token TOKEN_TYPE_INTEGER;
%token TOKEN_TYPE_BOOLEAN;
%token TOKEN_TYPE_FUNCTION;
%token TOKEN_TYPE_VOID;
%token TOKEN_TYPE_AUTO;
%token TOKEN_TYPE_CHAR;
%token TOKEN_TYPE_ARRAY;
%token TOKEN_GREATER_EQUAL;
%token TOKEN_GREATER;
%token TOKEN_EQUAL;
%token TOKEN_LESS;
%token TOKEN_LESS_EQUAL;
%token TOKEN_NOT_EQUAL;
%token TOKEN_AND;
%token TOKEN_OR;
%token TOKEN_NOT;
%token TOKEN_COLON;
%token TOKEN_SEMICOLON;
%token TOKEN_L_BRACKET;
%token TOKEN_R_BRACKET;
%token TOKEN_L_PAREN;
%token TOKEN_R_PAREN;
%token TOKEN_L_BRACE;
%token TOKEN_R_BRACE;
%token TOKEN_ASSIGN;
%token TOKEN_COMMA;
%token TOKEN_ERROR;

%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
//#include "token.h"
/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/

#define YYSTYPE int

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

int parser_result = 0;

extern char *yytext;
extern int yylex();
extern int yyerror(char * str);

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

//struct expr * parser_result = 0;

%}

%%

program:
	stmts { return 0; }
	| { return 0; }
	;

stmt:
	open_stmt
	| closed_stmt
	;

if_then:
	TOKEN_IF TOKEN_L_PAREN expr TOKEN_R_PAREN
	;

open_stmt:
	if_then open_stmt
	| if_then other_stmt
	| if_then closed_stmt TOKEN_ELSE open_stmt
	;

closed_stmt:
	if_then closed_stmt TOKEN_ELSE closed_stmt
	| other_stmt
	;

other_stmt:
	expr TOKEN_SEMICOLON
	| TOKEN_WHILE TOKEN_L_PAREN expr TOKEN_R_PAREN closed_stmt
	| TOKEN_FOR TOKEN_L_PAREN for_list TOKEN_R_PAREN closed_stmt
	| TOKEN_L_BRACE stmts TOKEN_R_BRACE
	| TOKEN_L_BRACE expr arg_list TOKEN_R_BRACE
	| TOKEN_PRINT expr arg_list TOKEN_SEMICOLON
	| TOKEN_PRINT TOKEN_SEMICOLON
	| TOKEN_RETURN expr TOKEN_SEMICOLON
	| TOKEN_RETURN TOKEN_SEMICOLON
	| decl
	;

stmts:
	stmt
	| stmt stmts
	;


for_list:
	opt_expr TOKEN_SEMICOLON opt_expr TOKEN_SEMICOLON opt_expr
	;

opt_expr:
	expr
	|
	;

param:
	TOKEN_IDENT TOKEN_COLON type
	;

decl:
	param TOKEN_SEMICOLON
	| param TOKEN_ASSIGN stmt
	;

type:
	TOKEN_TYPE_ARRAY TOKEN_L_BRACKET TOKEN_R_BRACKET type
	| TOKEN_TYPE_ARRAY TOKEN_L_BRACKET TOKEN_NUMBER TOKEN_R_BRACKET type
	| TOKEN_TYPE_AUTO
	| TOKEN_TYPE_BOOLEAN
	| TOKEN_TYPE_CHAR
	| TOKEN_TYPE_INTEGER
	| TOKEN_TYPE_STRING
	| TOKEN_TYPE_VOID
	| TOKEN_TYPE_FUNCTION type TOKEN_L_PAREN param param_list TOKEN_R_PAREN
	| TOKEN_TYPE_FUNCTION type TOKEN_L_PAREN TOKEN_R_PAREN
	;
	
param_list:
	TOKEN_COMMA param param_list
	|
	;

expr:
	expr TOKEN_LESS subexpr
	| expr TOKEN_GREATER subexpr
	| expr TOKEN_LESS_EQUAL subexpr
	| expr TOKEN_GREATER_EQUAL subexpr
	| expr TOKEN_EQUAL subexpr
	| expr TOKEN_NOT_EQUAL subexpr
	| expr TOKEN_AND subexpr
	| expr TOKEN_OR subexpr
	| expr TOKEN_ASSIGN subexpr
	| expr TOKEN_L_BRACKET expr TOKEN_R_BRACKET
	| subexpr
	;

subexpr:
	subexpr TOKEN_ADD term
	| subexpr TOKEN_SUBTRACT term
	| term
	;

term:
	term TOKEN_MULTIPLY factor
	| term TOKEN_DIVIDE factor
	| term TOKEN_MOD factor
	| factor
	;

factor:
	factor TOKEN_POWER atomic
	| factor TOKEN_INCREMENT
	| factor TOKEN_DECREMENT
	| atomic
	;

atomic:
	TOKEN_L_PAREN expr TOKEN_R_PAREN
	| TOKEN_IDENT TOKEN_L_PAREN expr arg_list TOKEN_R_PAREN
	| TOKEN_IDENT TOKEN_L_PAREN TOKEN_R_PAREN
	| TOKEN_SUBTRACT atomic
	| TOKEN_ADD atomic
	| TOKEN_NUMBER
	| TOKEN_CHAR
	| TOKEN_STRING
	| TOKEN_FALSE
	| TOKEN_TRUE
	| TOKEN_IDENT
	| TOKEN_NOT atomic
	;

arg_list:
	TOKEN_COMMA expr arg_list
	|
	;

%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror (char * str) {
	printf("parse error: %s\n", str);
	return 0;
}